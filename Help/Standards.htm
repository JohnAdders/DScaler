<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Coding Standards</TITLE>
<META NAME="Template" CONTENT="D:\office97\Office\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080">

<B><FONT SIZE=6><P ALIGN="CENTER">Coding Standards</P>
</FONT><P ALIGN="CENTER">The Deinterlace Project</P>
<P ALIGN="CENTER">Revision 1.0 </P>
<FONT SIZE=4><P>Abstract:</P>
</B></FONT><P>This document describes the <FONT FACE="Courier New">C++</FONT> Coding Standards as they are used in the <FONT FACE="Courier New">deinterlace</FONT> project. It provides a set of guidelines, rationales and standards for <FONT FACE="Courier New">C/C++</FONT> coding.</P>
<B><P>Copyright notice</P>
</B><FONT FACE="Courier New"><P>Deinterlace Copyright (c) 2001 John Adcock</P>
<P>Revision 1.6 , Last Modified: 2001/07/13</P>
</FONT><P>This material may be distributed only subject to the terms and conditions set forth in the Open Publication License.</P>
<P>&nbsp;</P>
<P>This document was based on the on the CoreLinux C++ Coding standards document version 1.6</P>
<P>The original document can be found <U><FONT COLOR="#0000ff">http://corelinux.sourceforge.net/cppstnd.php</P>
</U></FONT><P>&nbsp;</P>
<FONT FACE="Courier New"><P>CoreLinux++ Copyright (c) 1999, 2000 CoreLinux Consortium</P>
<P>Revision 1.6 , Last Modified: 2000/09/22</P>
</FONT><P>This material may be distributed only subject to the terms and conditions set forth in the Open Publication License.</P>
<P>&nbsp;</P>
<B><FONT FACE="Arial" SIZE=4><P>Scope</P>
</B></FONT><P>The principle function of this document is to establish a consistent standard which will provide for easier maintenance of code. This will benefit the team and the project in that those who are new to the code can quickly orient themselves, and thereby sooner become productive members of the team. It is intended to be a dynamic document and can be reviewed as needed. It is recommended that each programmer keep a copy on hand also. </P>
<B><I><FONT FACE="Arial"><P>Document Overview </P>
</B></I></FONT><P>The following document sections contain standards, guidelines, and rationales. Guidelines must be adhered to unless there is compelling reason to deviate. Deviation from a guideline must be discussed and approved during the code walk-through. A standard is an item to which compliance is mandatory. Deviation from a standard must be discussed, approved, and signed-off on by the team lead during the code walk-through. Rationales have been used where necessary to explain the meaning of an item, or why it was chosen. </P>
<B><FONT FACE="Arial"><P>General Principles</P><DIR>

</B></FONT><P>This section contains the basic philosophy a developer should keep in mind while coding. </P></DIR>

<B><FONT FACE="Arial"><P>Comments</P><DIR>

</B></FONT><P>This section deals with the placement and contents of comments in the code. </P></DIR>

<B><FONT FACE="Arial"><P>Code Layout</P><DIR>

</B></FONT><P>This section has to do with the alignment of the code, white space, declarations and keywords, and where they should all be located. </P></DIR>

<B><FONT FACE="Arial"><P>Naming Conventions</P><DIR>

</B></FONT><P>This section contains the structure for naming classes, functions, files, and directories. </P></DIR>

<B><FONT FACE="Arial"><P>Usage</P><DIR>

</B></FONT><P>This section concerns the 'how' and 'when' certain constructs should be used (for example, loops, inheritance, error handling, etc.) </P></DIR>

<B><FONT FACE="Arial"><P>File Layout</P><DIR>

</B></FONT><P>This section applies to where things should be located in header files and modules. </P>
<P>&nbsp;</P></DIR>

<B><FONT FACE="Arial" SIZE=4><P>General Principles </P>
</B></FONT><P>The primary goal of the coding standard is maintainability. Other important considerations that relate to the spirit of the standard are correctness, readability, consistency, extensibility, portability, clarity, and simplicity. When in doubt, the programmer should strive for clarity first, then efficiency. </P>
<P>Think of the reader. Do not just write for yourself. Keep it simple. Break down complexity into simpler chunks. Clearly comment necessary complexity. Be explicit. Avoid implicit or obscure language features. Be consistent. Minimize scope, both logical and visual. </P>
<P>Much of the code in DScaler does not conform to these standards.  Please when making changes try to apply the standards to any surrounding code.  This is especially true of comments and variable naming.</P>
<B><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P>Comments </P>
</B></FONT><P>&nbsp;</P>
<I><P>Guideline 1:</I>&#9;Be clear and concise. Say what is happening and why. Do not restate code. </P>
<P>&nbsp;</P>
<I><P>Guideline 2:</I>&#9;Keep code and comments visually separate. </P>
<P>&nbsp;</P>
<I><P>Standard 1:</I>&#9;Use top of file comments for all files. Include CVS $Id$ and $Log$ tags on this block.  Include the correct GPL comment and assign copyright to yourself for totally new files or the same as the original source if splitting files.</P>
<P>&nbsp;</P>
<I><P>Standard 1:</I>&#9;Use only the <FONT FACE="Courier New">C++</FONT> comment style (double slashes) for single line comments. </P>
<P>&nbsp;</P>
<I><P>Guideline 3:</I>&#9;For block comment styles either <FONT FACE="Courier New">C++</FONT> (double slashes) or C style (<FONT FACE="Courier New">/* ... */</FONT>) can be used. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>   // ...</P>
</FONT><P>-OR- </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>   /* ...  */</P>
</FONT><P>&nbsp;</P>
<P>&nbsp;</P>
<I><P>Guideline 4:</I>&#9;Prefer block comments over trailing comments. Use block comments regularly. Only use trailing comments for special items. </P>
<P>&nbsp;</P>
<I><P>Standard 5:</I>&#9;Trailing comments must all start in the same column in the function. </P>
<P>&nbsp;</P>
<I><P>Standard 6:</I>&#9;Trailing comments at a closing brace are indented one level from brace. </P>
<P>&nbsp;</P>
<I><P>Standard 7:</I>&#9;Block comments are at the same indentation level as the block they describe. </P>
<P>&nbsp;</P>
<I><P>Standard 8:</I>&#9;Ensure comments are correct (and stay correct). </P>
<B><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P>Code Layout </P>
</B></FONT><I><P>Guideline 5:</I>&#9;Write code in a series of chunks. </P>
<P>&nbsp;</P>
<I><P>Guideline 6:</I>&#9;Use block comments to separate the chunks. </P>
<P>&nbsp;</P>
<I><P>Standard 9:</I>&#9;Put one statement per line, except with in-line code in a header file. </P>
<P>&nbsp;</P>
<I><P>Guideline 7:</I>&#9;Functions shall have a single exit point. Exceptions to this rule are allowed in simple cases (e.g. where functions are less than 15 lines) and for invalid parameter checks.</P>
<P>&nbsp;</P>
<I><P>Rationale:</I>&#9;Multiple exit points usually add to the complexity of a function. </P>
<P>&nbsp;</P>
<I><P>Standard 10:</I>&#9;Indentation level is four (4) spaces. Set editor to replace tabs with spaces</P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Braces and Parenthesis </P>
</B></FONT><P>Standard 11:</I>&#9;Braces shall be aligned using Ulman style where the braces are at the same scope as the statement that proceeds them and the code within the braces is indented one level. Braces are always on a line by themselves. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>void DoSomething( void )</P>
<P>{</P>
<P>   if(x != y)</P>
<P>   {</P>
<P>      y = x;</P>
<P>   }</P>
<P>   else</P>
<P>   {</P>
<P>      ; // do nothing</P>
<P>   }            </P>
<P>}</P>
</FONT><P>-NOT- </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>void DoSomething( void )</P>
<P>{</P>
<P>   if(x != y)</P>
<P>   {</P>
<P>   y = x;    // should be indented</P>
<P>   }</P>
<P>   else</P>
<P>   {</P>
<P>      ; // do nothing</P>
<P>   }            </P>
<P>}</P>
</FONT><P>- OR - </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>void DoSomething( void )</P>
<P>{</P>
<P>   if(x != y)</P>
<P>      {             // brace is not the same scope</P>
<P>      y = x;</P>
<P>      }</P>
<P>   else</P>
<P>      {</P>
<P>      ; // do nothing</P>
<P>      }            </P>
<P>}</P>
</FONT><P>- OR - </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>void DoSomething( void )</P>
<P>{</P>
<P>   if(x != y){   // brace is not on a line by itself</P>
<P>      y = x;</P>
<P>      }</P>
<P>   else{</P>
<P>      ; // do nothing</P>
<P>      }            </P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 12:</I>&#9;While, for and if statements shall always use braces, even if they are not syntactically required. </P>
<P>&nbsp;</P>
<I><P>Guideline 8:</I>&#9;Use parenthesis to group within a statement and to emphasize evaluation order. </P>
<P>&nbsp;</P>
<I><P>Guideline 9:</I>&#9;Avoid unnecessary parentheses. </P>
<P>&nbsp;</P>
<I><P>Guideline 10:</I>&#9;Avoid deep (more than three) levels of parenthesis nesting. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Declarations </P>
</B></FONT><P>Standard 14:</I>&#9;Start each declaration on a new line. (Except for loops where the counter can be defined within the statement)</P>
<P>&nbsp;</P>
<I><P>Standard 15:</I>&#9;Enumeration declarations will be declared with named constants in upper case and the identifier specified as described in Naming conventions. Where it is expected that code will iterate over the space defined by the enum then there should be a ???_LAST_ONE entry defined.</P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>enum eIdentifier</P>
<P>{</P>
<P>   ONE,</P>
<P>   TWO,</P>
<P>   THREE</P>
<P>};</P>
</FONT><P>- or - </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>enum eIdentifier</P>
<P>{</P>
<P>   ONE = 1,</P>
<P>   TWO,</P>
<P>   THREE,</P>
<P>   IDENTIFIER_LAST_ONE,</P>
<P>};</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 16:</I>&#9;All variables must be initialized. </P>
<P>&nbsp;</P>
<I><P>Guideline 11:</I>&#9;Use vertical alignment to ease scanning of declarations. Where possible the variable names should start in column 15.</P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>STRING          StringToUse;</P>
<P>int             MyInt;</P>
<P>COMPLEX         ComplexNumberToUse;</P>
</FONT><P>-instead of- </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>STRING StringToUse;</P>
<P>int MyInt;</P>
<P>COMPLEX ComplexNumberToUse;</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 17:</I>&#9;Do not create anonymous types (structs), except in a class declaration where a private structure is declared. </P>
<B><I><FONT FACE="Arial"><P>Keyword Constructs </P>
</B></I></FONT><P>&nbsp;</P>
<I><P>Standard 19:</I>&#9;Nested else if statements shall be indented as normal statements, the if shall appear on the same line as the else, and shall have a final else statement (most likely with a <FONT FACE="Courier New">NEVER_GET_HERE</FONT>; statement). </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>if( x &gt; y )</P>
<P>{</P>
<P>   x = x - y;</P>
<P>}</P>
<P>else if( x &lt; y )</P>
<P>{</P>
<P>   y = y - x;</P>
<P>}       </P>
<P>else</P>
<P>{</P>
<P>   // x and y should never be equal</P>
<P>   NEVER_GET_HERE;</P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 20:</I>&#9;Cases should be at the same level as the <FONT FACE="Courier New">switch</FONT> and indent the code one level beyond the case. The break statement is at the same indentation level as the code. </P>
<P>&nbsp;</P>
<I><P>Standard 21:</I>&#9;All <FONT FACE="Courier New">switch</FONT> statements shall have a <FONT FACE="Courier New">default</FONT> case. If all cases have been handled then the default code shall be <FONT FACE="Courier New">NEVER_GET_HERE</FONT>. If not then it shall be an empty statement. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>switch(Variable)</P>
<P>{</P>
<P>case  1:</P>
<P>    // ... code ...</P>
<P>    break;</P>
<P>&nbsp;</P>
<P>case  2:</P>
<P>    // ... code ...</P>
<P>    break;</P>
<P>&nbsp;</P>
<P>default:</P>
<P>    NEVER_GET_HERE;</P>
<P>    break;</P>
<P>}</P>
</FONT><P>- OR - </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>switch( variable )</P>
<P>{</P>
<P>case  1:</P>
<P>    // ... code ...</P>
<P>    break;</P>
<P>&nbsp;</P>
<P>case  2:</P>
<P>    // ... code ...</P>
<P>    break;</P>
<P>           </P>
<P>default:</P>
<P>    ;         // do nothing</P>
<P>    break;</P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 22:</I>&#9;Put the <FONT FACE="Courier New">while</FONT> in a <FONT FACE="Courier New">do while</FONT> statement on the same line as the closing brace. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>do</P>
<P>{</P>
<P>    ++x;</P>
<P>} while(x &lt; y);</P>
</FONT><B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Preprocessor </P>
</B></FONT><P>Guideline 13:</I>&#9;Preprocessor directives should be avoided whenever possible. </P>
<P>&nbsp;</P>
<I><P>Standard 25:</I>&#9;Multi-statement macros shall have one statement per line. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>#define MULTIPLE_LINE_MACRO( s )        \</P>
<P>        ++(s);                          \</P>
<P>        (s) = ((s) % 3 ? ++(s) : (s) )</P>
</FONT><B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Spaces </P>
</B></I></FONT><FONT COLOR="#ff0000"><P>&lt;SPAN ID="txt646"&gt;&lt;SPAN CLASS="textbf"&gt;</FONT>NOTE:<FONT COLOR="#ff0000">&lt;/SPAN&gt;&lt;/SPAN&gt;</FONT> Adhere to the indentation standard. </P>
<P>&nbsp;</P>
<I><P>Standard 26:</I>&#9;Do not use spaces in object de-references. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>val = *pFoo;    // ok</P>
<P>val = * pFoo;   // wrong</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 27:</I>&#9;When defining pointer types put asterix next to type with no spaces. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>CClass* pFoo;        // ok</P>
<P>CClass *pFoo;        // wrong</P>
<P>CClass foo, *pFoo;   // very wrong</P>
<P>&nbsp;</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 28:</I>&#9;Do not space between an unary operator and its operand, but do space the other side. </P>
<P>&nbsp;</P>
<I><P>Standard 29:</I>&#9;Balance spacing on either side of binary operators. </P>
<P>&nbsp;</P>
<I><P>Standard 30:</I>&#9;Do not space before separators ( semicolon, argument comma separator ) but do space the other side. </P>
<P>&nbsp;</P>
<I><P>Standard 32:</I>&#9;Balance spacing inside parenthesis. </P>
<P>&nbsp;</P>
<I><P>Standard 34:</I>&#9;Use blank lines before and after block comments. </P>
<P>&nbsp;</P>
<I><P>Standard 35:</I>&#9;Use vertical alignment to indicate association. </P>
<P>&nbsp;</P>
<I><P>Standard 36:</I>&#9;Use spaces, not tabs. </P>
<P>&nbsp;</P>
<I><P>Rationale:</I>&#9;Tab sizes vary between developers. When spaces are used, the alignment is maintained no matter where the file is edited. </P>
<B><I><FONT FACE="Arial"><P>Wrapping </P>
</B></FONT><P>Guideline 15:</I>&#9;No line of code should extend beyond column 100. </P>
<P>&nbsp;</P>
<I><P>Rationale:</I>&#9;When the audience for the source and headers of a project may reach hundreds, if not more, readability and continuity become prime factors for comprehension. Additionally, in a multi-developer environment, the potential for disjoint style is personified with no restrictions on column length. </P>
<P>&nbsp;</P>
<I><P>Standard 37:</I>&#9;When wrapping lines, indent the continuation line past the current indent column. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>int     Val(2);</P>
<P>        </P>
<P>cout &lt;&lt; "This is an example where I wrap " </P>
<P>    &lt;&lt; Val </P>
<P>    &lt;&lt; " lines of code" &lt;&lt; endl;</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 38:</I>&#9;Wrap assignments past the equal sign. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>CObjectMapConstIterator  Iterator;</P>
<P>&nbsp;</P>
<P>Iterator = m_MapOfObjects.begin();</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 39:</I>&#9;Wrap conditional expressions after the operators. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>if(m_NameOfTheGame == gameName &amp;&amp; </P>
<P>   m_TimeBeingPlayed &gt; Limit)</P>
<P>{</P>
<P>    // ...</P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 40:</I>&#9;Wrap <FONT FACE="Courier New">for</FONT> statements after the semi-colons. </P>
<P>&nbsp;</P>
<I><P>Standard 41:</I>&#9;Wrap long function signatures with one parameter per line. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>void CClassMethod::setValues</P>
<P>    (</P>
<P>        const Object&amp; Object1,</P>
<P>        const Object&amp; Object2,</P>
<P>        const STRING&amp; Name,</P>
<P>        const int     Value,</P>
<P>        ...</P>
<P>    )</P>
<P>{</P>
<P>   ;</P>
<P>}</P>
</FONT><B><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P>Naming Conventions </P>
</B></FONT><I><P>Standard 42:</I>&#9;Spell words using correct English spelling. For the most part, avoid abbreviations. Abbreviations for common longwinded phases may be used as though they are normal words if the abbreviation is placed in the Glossary and the usage remains clear in the context.</P>
<FONT FACE="Courier New"><P>&nbsp;</P>
</FONT><I><P>Rationale:</I>&#9;The semantics of a type are much better understood by the reader when they have names like "SpeakerCabinet" instead of "SpkCb". </P>
<P>&nbsp;</P>
<I><P>Guideline 16:</I>&#9;Make names clearly unique. Avoid similar-sounding names and similarly-spelled names. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>int      Count;</P>
<P>STRING   Surname;</P>
<P>CObject  Person;</P>
</FONT><P>- INSTEAD OF - </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>Int     x1;</P>
<P>String  x2;</P>
<P>Object  x3;</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 43:</I>&#9;Make all identifiers unique within a function. </P>
<P>&nbsp;</P>
<I><P>Standard 44:</I>&#9;Use mixed case to distinguish name segments instead of underscores. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>CWellFormedObject       WellFormedObject;        // ok</P>
<P>non_standard_form       Wellformedobject;        // wrong</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 45:</I>&#9;Types are all upper case and use underscores to separate name segments. (i.e. <FONT FACE="Courier New">CURRENCY</FONT>, <FONT FACE="Courier New">BIG_CAR,STRING</FONT>). </P>
<P>&nbsp;</P>
<I><P>Standard 46:</I>&#9;Variables and objects names that are data members of a class start with a '<FONT FACE="Courier New">m_</FONT>' and followed by an upper case letter then mixed case. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>class CFoo</P>
<P>{</P>
<P>public:</P>
<P>&#9;//</P>
<P>        </P>
<P>protected:</P>
<P>    NEW_TYPE        m_NewType;</P>
<P>};</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 47:</I>&#9;Variables and objects names that are arguments or locals start with an upper case letter and are mixed case thereafter. (i.e. <FONT FACE="Courier New">NEW_TYPE </FONT> NewType<FONT FACE="Courier New">;</FONT> ). </P>
<P>&nbsp;</P>
<I><P>Standard 48:</I>&#9;Pointer variable names are prefixed <FONT FACE="Courier New">'p'</FONT> followed by an upper case letter.</P>
<P>&nbsp;</P>
<I><P>Guideline 17:</I>&#9;Only use short variable names when they have limited scope and obvious meaning. Beware of them causing confusion. Short variables may be lower case e.g. i in loops.</P>
<P>&nbsp;</P>
<I><P>Standard 49:</I>&#9;Use capital letters to begin new name segments within the name. </P>
<P>&nbsp;</P>
<I><P>Guideline 18:</I>&#9;Name functions with verb-noun (verb object) combinations.  The first letter of functions should be upper case.</P>
<P>&nbsp;</P>
<I><P>Guideline 19:</I>&#9;Name variables and structures with noun, adjective noun combinations. </P>
<P>&nbsp;</P>
<I><P>Standard 50:</I>&#9;Accessor methods start with the word '<FONT FACE="Courier New">Get</FONT>' and should be <FONT FACE="Courier New">const</FONT>. </P>
<P>&nbsp;</P>
<I><P>Standard 51:</I>&#9;Boolean accessor functions start with '<FONT FACE="Courier New">Is</FONT>' and return <FONT FACE="Courier New">bool</FONT>. </P>
<P>&nbsp;</P>
<I><P>Standard 52:</I>&#9;Mutator procedures start with the word '<FONT FACE="Courier New">Put</FONT>' and don't return values. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>class CFoo</P>
<P>{</P>
<P>public:</P>
<P>&nbsp;</P>
<P>   //</P>
<P>   // Accessor</P>
<P>   //</P>
<P>           </P>
<P>   const BSTR   GetName(void) const;</P>
<P>   bool         IsNameEmpty(void) const;</P>
<P>           </P>
<P>   //</P>
<P>   // Mutator</P>
<P>   //</P>
<P>           </P>
<P>   void         PutName(const BSTR name);</P>
<P>        </P>
<P>protected:</P>
<P>  </P>
<P>   BSTR         m_Name;</P>
<P>};</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 53:</I>&#9;Factory instantiation functions start with the word '<FONT FACE="Courier New">Create</FONT>'. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>CThread* CreateThread(void);</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 54:</I>&#9;Factory destruction functions start with the word '<FONT FACE="Courier New">Destroy</FONT>'. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>void DestroyThread(CThread* threadToDestroy);</P>
</FONT><B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Files and Directories </P>
</B></I></FONT><P>&nbsp;</P>
<I><P>Guideline 20:</I>&#9;Name files like variables, describing the functions they contain. Long file names are encouraged. </P>
<P>&nbsp;</P>
<I><P>Standard 56:</I>&#9;Use <FONT FACE="Courier New">.cpp</FONT> and <FONT FACE="Courier New">.h</FONT> for class definition source and header file suffixes. </P>
<P>&nbsp;</P>
<I><P> Standard 57:</I>&#9;Any procedural code written should be compiled in <FONT FACE="Courier New">C++</FONT> . </P>
<P>&nbsp;</P>
<I><P>Rationale:</I>&#9;<FONT FACE="Courier New">C++</FONT> compilers provide much stricter type checking than C compilers. The stronger type checking is well worth using, even if the code does not take advantage of the object oriented features of <FONT FACE="Courier New">C++</FONT> . </P>
<P>&nbsp;</P>
<I><P>Guideline 23:</I>&#9;Name directories like nested structures. </P>
<B><FONT FACE="Arial" SIZE=4><P>Usage </P>
</B></FONT><I><P>Guideline 24:</I>&#9;There are no circumstances where <FONT FACE="Courier New">goto</FONT> is allowed. </P>
<P>&nbsp;</P>
<I><P>Guideline 25:</I>&#9;Avoid deep nesting of statements, parentheses, and structures. </P>
<P>&nbsp;</P>
<I><P>Guideline 26:</I>&#9;All assignments shall stand alone, unless a series of variables are being assigned to the same value. </P>
<P>&nbsp;</P>
<I><P>Standard 58:</I>&#9;Do not use comparisons in mathematical expressions. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>numberOfDays = ( get_IsLeapYear() == TRUE ) + 28; // not OK</P>
</FONT><P>&nbsp;</P>
<I><P>Guideline 59:</I>&#9;All non-boolean comparison expressions should use a comparison operator. Do not use implicit <FONT FACE="Courier New">!= 0</FONT>. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>ASSERT(pObject != 0);          // good</P>
<P>ASSERT(pObject);              // bad</P>
</FONT><P>&nbsp;</P>
<I><P>Guideline 27:</I>&#9;Avoid assignment in comparisons, except where the alternative is significantly more complex. </P>
<P>&nbsp;</P>
<I><P>Standard 60:</I>&#9;Use explicit casting, instead of the compiler default. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>DWORD   UnsignedValue(0);</P>
<P>REAL    RealValue(3.7);</P>
<P>&nbsp;</P>
<P>BigValue = DWORD(RealValue);</P>
</FONT><P>Also note that the class operator overloads should be used as a preference for upcasting and downcasting: </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>class CFoo</P>
<P>{</P>
<P>public:</P>
<P>   </P>
<P>   //</P>
<P>   // Accessor</P>
<P>   //</P>
<P>&nbsp;</P>
<P>   operator      DWORD(void) const</P>
<P>   { </P>
<P>      return DWORD(m_Value); </P>
<P>   }</P>
<P>                </P>
<P>   operator      SHORT(void) const</P>
<P>   { </P>
<P>      return SHORT(m_Value);</P>
<P>   }</P>
<P>        </P>
<P>   //</P>
<P>   // Mutator</P>
<P>   //</P>
<P>     </P>
<P>protected:</P>
<P>&nbsp;</P>
<P>   REAL          m_Value;</P>
<P>};</P>
</FONT><P>&nbsp;</P>
<I><P>Guideline 28:</I>&#9;Default to pre-increment and pre-decrement unless the post-increment/decrement operators are logically necessary. </P>
<P>&nbsp;</P>
<I><P>Guideline 29:</I>&#9;Minimize negative comparisons. </P>
<P>&nbsp;</P>
<I><P>Guideline 30:</I>&#9;Minimize use of the comma operator. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Conditionals </P>
</B></FONT><P>Guideline 31:</I>&#9;Use <FONT FACE="Courier New">if (</FONT> cond) ...<FONT FACE="Courier New">else</FONT> rather than conditional expressions <FONT FACE="Courier New">( (</FONT> cond<FONT FACE="Courier New">) ? : )</FONT> if only to clarify the intended operation. </P>
<P>&nbsp;</P>
<I><P>Guideline 32:</I>&#9;Use nested if only to clarify the intended order of evaluation. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>if( Foo() == true )</P>
<P>{</P>
<P>    if( Bar() == true )</P>
<P>    {</P>
<P>    }</P>
<P>}</P>
</FONT><P>-- VERSUS—</P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>if( Foo() &amp;&amp; Bar() )</P>
<P>{</P>
<P>&nbsp;</P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 61:</I>&#9;In a <FONT FACE="Courier New">switch</FONT> statement, make all cases independent by using break at the end of each. All switch statements should have a default. If all cases have been handled, then the default should never be <FONT FACE="Courier New">NEVER_GET_HERE</FONT>. This is also true for if...elseif...else blocks. </P>
<P>&nbsp;</P>
<I><P>Standard 62:</I>&#9;Use <FONT FACE="Courier New">if...else</FONT> for two alternative actions. Put the major action first. Exceptions to this standard are checks at the top of a function.</P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Loop Constructs </P>
</B></FONT><P>Guideline 33:</I>&#9;Count for loops in ascending. </P>
<FONT FACE="Courier New"><P>for(int x(0); x &lt; ListSize; ++x)</P>
<P>{</P>
<P>   // code</P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 63:</I>&#9;Use for loops when the loop control needs initializing or recalculating; otherwise, use while. </P>
<FONT FACE="Courier New"><P>// go backwards down array</P>
<P>x = ArrayOfThings.GetSize();</P>
<P>while(x-- &gt; 0)</P>
<P>{</P>
<P>   Array[x].DoSomethingWithThing();</P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 64:</I>&#9;Use <FONT FACE="Courier New">while( 1 )</FONT> to implement an infinite loop. Make its usage clear with comments. </P>
<P>&nbsp;</P>
<I><P>Guideline 34:</I>&#9;Be careful with the logic of do loops. Use <FONT FACE="Courier New">do...while( !(...) ) </FONT>to loop until a comparison becomes true. </P>
<P>&nbsp;</P>
<I><P>Guideline 35:</I>&#9;Minimize use of <FONT FACE="Courier New">break</FONT> in loops. Only use it for abnormal escape. </P>
<P>&nbsp;</P>
<I><P>Guideline 36:</I>&#9;Use <FONT FACE="Courier New">continue</FONT> sparingly. Clearly comment why <FONT FACE="Courier New">continue</FONT> is used. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Data </P>
</B></FONT><P>Guideline 38:</I>&#9;Beware of operations with constants going out of range. </P>
<P>&nbsp;</P>
<I><P>Standard 67:</I>&#9;Use single-quoted characters for character constants, but never single-quote more than one character (or hex for non-printing). </P>
<P>&nbsp;</P>
<I><P>Standard 68:</I>&#9;Use <FONT FACE="Courier New">sizeof</FONT> rather than a constant. </P>
<P>&nbsp;</P>
<I><P>Standard 69:</I>&#9;Do not compare floating point numbers for equality. </P>
<P>&nbsp;</P>
<I><P>Standard 70:</I>&#9;Assign to all data members in <FONT FACE="Courier New">operator=</FONT>. </P>
<P>&nbsp;</P>
<I><P>Standard 71:</I>&#9;Check for assignment to <FONT FACE="Courier New">this</FONT> in <FONT FACE="Courier New">operator=</FONT>. If assignment to <FONT FACE="Courier New">this</FONT> is attempted, simply return from the function. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>MyClassRef  MyClass::operator=( MyClassCref aRef )</P>
<P>{</P>
<P>   if( this != &amp;aRef )</P>
<P>   {</P>
<P>      //      do the assignment</P>
<P>      ...</P>
<P>   }</P>
<P>   else</P>
<P>   {</P>
<P>      ;   // do nothing        </P>
<P>   }</P>
<P>   return *this;</P>
<P>}</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 72:</I>&#9;Make sure <FONT FACE="Courier New">operator=</FONT> invokes any parents' <FONT FACE="Courier New">operator=</FONT>, except with virtual inheritance. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P> Initialization </P>
</B></FONT><P>Standard 77:</I>&#9;Explicitly initialize static data. </P>
<P>&nbsp;</P>
<I><P>Standard 78:</I>&#9;Initialize all variables at the time they are declared to the appropriate value. If the value is not yet known, initialize pointers to simple types to zero or NULL. </P>
<P>&nbsp;</P>
<I><P>Standard 79:</I>&#9;List members in a constructor initialization list in order in which they are declared in the class header. </P>
<P>&nbsp;</P>
<I><P>Standard 80:</I>&#9;Check for empty pointer or handle by comparison with NULL. </P>
<B><I><FONT FACE="Arial"><P>Declaration </P>
</B></FONT><P>Guideline 40:</I>&#9;All data should be defined as close as possible to where it is needed. </P>
<P>&nbsp;</P>
<I><P> Guideline 41:</I>&#9;Use floating point numbers only where necessary. </P>
<P>&nbsp;</P>
<I><P> Guideline 42:</I>&#9;Do not use global data. Consider putting global information in the context of a static class. </P>
<P>&nbsp;</P>
<I><P> Guideline 43:</I>&#9;Do not use unions. </P>
<P>&nbsp;</P>
<I><P> Guideline 44:</I>&#9;Do not use bit structures. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Programming </P>
</B></FONT><P>Guideline 45:</I>&#9;Make sure interface definitions are clear and sufficient. </P>
<P>&nbsp;</P>
<I><P>Guideline 46:</I>&#9;Defend against system, program and user errors. Heavy use of assertions and exceptions are encouraged. </P>
<P>&nbsp;</P>
<I><P>Guideline 47:</I>&#9;Enable the user and the maintainer to find sufficient information to understand an error. Include enough diagnostic information to give an accurate picture of why the error occurred. </P>
<P>&nbsp;</P>
<I><P>Guideline 48:</I>&#9;Do not use arbitrary, predefined limits( e.g. on symbol table entries, user names, file names). </P>
<P>&nbsp;</P>
<I><P>Standard 87:</I>&#9;Use the same form in corresponding calls to <FONT FACE="Courier New">new</FONT> and <FONT FACE="Courier New">delete</FONT> (i.e. <FONT FACE="Courier New">new CFoo</FONT> uses <FONT FACE="Courier New">delete pFoo</FONT> and <FONT FACE="Courier New">new CFoo[100]</FONT> uses <FONT FACE="Courier New">delete []</FONT> <FONT FACE="Courier New">fooArray</FONT>. </P>
<P>&nbsp;</P>
<I><P>Guideline 50:</I>&#9;Know what <FONT FACE="Courier New">C++</FONT> silently creates and calls (e.g. default constructor, copy constructor, assignment operator, address-of operators(const and not), and the destructor for a derived class where the base class's destructor is defined.) </P>
<P>&nbsp;</P>
<I><P>Standard 88:</I>&#9;Ensure that objects (both simple and class) are initialized before they are used. </P>
<P>&nbsp;</P>
<I><P>Standard 83:</I>&#9;Eradicate all compiler warnings. Set the compiler to the highest warning level. Any unavoidable warnings must be explicitly commented in the code. Unavoidable compiler warnings should be extremely rare. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Class and Functions </P>
</B></FONT><P>Guideline 51:</I>&#9;Strive for class interfaces that are complete and minimal. </P>
<P>&nbsp;</P>
<I><P>Guideline 52:</I>&#9;The programmer should only have to look at the .h file to use a class. </P>
<P>&nbsp;</P>
<I><P> Guideline 53:</I>&#9;Do not put data members in the public interface. </P>
<P>&nbsp;</P>
<I><P>Standard 90:</I>&#9;Pass and return objects be reference instead of value whenever possible. </P>
<P>&nbsp;</P>
<I><P>Standard 91:</I>&#9;If the passed object is not going to be modified then pass it as a const reference. </P>
<P>&nbsp;</P>
<I><P>Standard 92:</I>&#9;The keyword class will appear in the left most column. If declaring the class in the scope of a namespace, then class will be indented appropriately. </P>
<P>&nbsp;</P>
<I><P>Standard 93:</I>&#9;The member access controls appear flush with the class keyword. </P>
<P>&nbsp;</P>
<I><P>Standard 94:</I>&#9;Access controls that have no members may be omitted. </P>
<P>&nbsp;</P>
<I><P>Standard 95:</I>&#9;Access controls appear in the following order </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>public:         //      Public method declarations</P>
<P>protected:      //      Protected method declarations</P>
<P>private:        //      Private method declarations</P>
<P>protected:      //      Protected class data members</P>
<P>private:        //      Private class data members</P>
</FONT><P>comments here are for clarification. </P>
<P>&nbsp;</P>
<I><P>Standard 96:</I>&#9;The virtual or static declarations appear in the first indentation level from the class declaration. </P>
<P>&nbsp;</P>
<I><P>Standard 97:</I>&#9;The return type of a class method or the storage type of a class data member appear after the first tab position beyond the space were virtual applied. </P>
<P>&nbsp;</P>
<I><P>Standard 98:</I>&#9;Method identifiers follow the return type and should be reasonably lined with other method declarations. </P>
<P>&nbsp;</P>
<I><P>Standard 99:</I>&#9;In each access control group for methods, Constructors are followed by destructor, followed by operator overloads, followed by accessors followed by mutators. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>class CMyClass</P>
<P>{</P>
<P>&nbsp;</P>
<P>public:</P>
<P>&nbsp;</P>
<P>   /// Default constructor</P>
<P>            </P>
<P>   CMyClass(void)</P>
<P>&nbsp;</P>
<P>   /**</P>
<P>      Copy constructor</P>
<P>      @param Object constant reference</P>
<P>    */</P>
<P>            </P>
<P>   CMyClass(const Object&amp; init);</P>
<P>             </P>
<P>   /// Destructor</P>
<P>&nbsp;</P>
<P>   virtual         ~CMyClass(void);</P>
<P>&nbsp;</P>
<P>   /**</P>
<P>      Equality operator overload</P>
<P>      @param CMyClass constant reference</P>
<P>      @return bool - true if equal, false otherwise</P>
<P>    */</P>
<P>             </P>
<P>   bool  operator==(const CMyClass&amp; copy);</P>
<P>&nbsp;</P>
<P>   //</P>
<P>   // Accessors</P>
<P>   //</P>
<P>&nbsp;</P>
<P>   /**</P>
<P>      Get the number of MyClass instantiations.</P>
<P>      @return Int const reference to count</P>
<P>    */</P>
<P>&nbsp;</P>
<P>   static    const INT      GetInstanceCount(void);</P>
<P>&nbsp;</P>
<P>   /**</P>
<P>      Return the object data member</P>
<P>      @return Object const reference</P>
<P>    */</P>
<P>&nbsp;</P>
<P>   const CObject&amp;   GetObject(void) const;</P>
<P>&nbsp;</P>
<P>   //</P>
<P>   // Mutators</P>
<P>   //</P>
<P>&nbsp;</P>
<P>   /**</P>
<P>      Sets the something thing</P>
<P>      @param Something const reference</P>
<P>    */</P>
<P>         </P>
<P>   virtual   void         PutSomething(const CSomething&amp; something);</P>
<P>&nbsp;</P>
<P>protected:</P>
<P>&nbsp;</P>
<P>   /// Copy never allowed</P>
<P>             </P>
<P>   CMyClass(const CMyClass&amp; ) throw(Assertion)</P>
<P>   { </P>
<P>      NEVER_GET_HERE; </P>
<P>   }</P>
<P>&nbsp;</P>
<P>   /// Assignment operator denied </P>
<P>                              </P>
<P>   CMyClassRef   operator=( const CMyClass&amp; ) throw(Assertion)</P>
<P>   {</P>
<P>      NEVER_GET_HERE;</P>
<P>      return *this;</P>
<P>   }   </P>
<P>private:</P>
<P>&nbsp;</P>
<P>   // No private methods</P>
<P>  </P>
<P>protected:</P>
<P>&nbsp;</P>
<P>   // No public data members                 </P>
<P>  </P>
<P>private:</P>
<P>&nbsp;</P>
<P>   /// Class instance counter</P>
<P>&nbsp;</P>
<P>   static int   m_InstanceCount;</P>
<P>};</P>
</FONT><P>&nbsp;</P>
<I><P>Guideline 54:</I>&#9;Don't return a reference, or pointer, when you must return an object, and don't return an object when you mean a reference. </P>
<P>&nbsp;</P>
<I><P>Guideline 55:</I>&#9;Avoid overloading on a pointer and a numerical type. (i.e. <FONT FACE="Courier New">Foo(char *)</FONT> vs. <FONT FACE="Courier New">Foo(int)</FONT> - a call to <FONT FACE="Courier New">Foo(0)</FONT> is ambiguous). </P>
<P>&nbsp;</P>
<I><P>Standard 100:</I>&#9;Do not return handles to internal data from const member functions. If a handle must be returned, make it const. </P>
<P>&nbsp;</P>
<I><P>Standard 101:</I>&#9;Avoid member functions that return pointers or references to members less accessible than themselves. Use <FONT FACE="Courier New">const</FONT> ! </P>
<P>&nbsp;</P>
<I><P>Standard 102:</I>&#9;Never return a reference to a local object or a de-referenced pointer initialized by new within the function. </P>
<P>&nbsp;</P>
<I><P>Rationale:</I>&#9;Obviously, when a functions ends, the local object goes out of scope, and the reference is no longer valid. One might attempt to NEW the object in the function instead, but then who would call the corresponding DELETE? </P>
<P>&nbsp;</P>
<I><P>Standard 103:</I>&#9;Use enums for integral class constants. </P>
<P>&nbsp;</P>
<I><P>Guideline 57:</I>&#9;Use inlining judiciously. </P>
<P>&nbsp;</P>
<I><P>Guideline 58:</I>&#9;Inlines cause code bloat, slow down compile times, eat up name space, and not all compilers handle them the same way.</P>
<B><I><FONT FACE="Arial"><P>Inheritance </P>
</B></FONT><P>Guideline 59:</I>&#9;Make sure public inheritance models 'is-a'. </P>
<P>&nbsp;</P>
<I><P>Guideline 60:</I>&#9;Differentiate between inheritance of the interface and of the implementation, and prefer delegation to implementation inheritance. </P>
<P>&nbsp;</P>
<I><P>Rationale:</I>&#9;Inheritance of the interface only is forced by making a function pure virtual- its implementation must be defined by the derived class. Inheritance of implementation occurs when the function is declared as simple virtual-derived classes may or may not override the implementation. </P>
<P>&nbsp;</P>
<I><P>Standard 106:</I>&#9;Never redefine an inherited non-virtual function. </P>
<P>&nbsp;</P>
<I><P>Standard 107:</I>&#9;Never redefine an inherited default parameter value. </P>
<P>&nbsp;</P>
<I><P>Guideline 61:</I>&#9;Use private inheritance judiciously. </P>
<P>&nbsp;</P>
<I><P>Guideline 62:</I>&#9;Differentiate between inheritance and templates. </P>
<P>&nbsp;</P>
<I><P>Rationale:</I>&#9;If the type of the object being manipulated does not affect the behavior or the class, then a template will do. However, if the type of the object DOES affect the behavior, then virtual functions should be used through inheritance. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Object-Oriented Considerations </P>
</B></FONT><P>Standard 109:</I>&#9;Factor our common code into an ancestor. </P>
<P>&nbsp;</P>
<I><P>Guideline 63:</I>&#9;Encapsulate external code within an operation or class. </P>
<P>&nbsp;</P>
<I><P>Guideline 64:</I>&#9;Keep member functions small, coherent and consistent. </P>
<P>&nbsp;</P>
<I><P>Guideline 65:</I>&#9;Separate policy member functions (e.g. error and status checkers) from implementation member functions (computational). </P>
<P>&nbsp;</P>
<I><P>Standard 110:</I>&#9;Do not use indirect function calls unless absolutely necessary. </P>
<P>&nbsp;</P>
<I><P>Standard 111:</I>&#9;Write member functions for all combinations of input conditions. Avoid using modes to distinguish between conditions. Use member function overloading instead. </P>
<P>&nbsp;</P>
<I><P>Standard 112:</I>&#9;Avoid case statements on object type; use member functions instead. </P>
<P>&nbsp;</P>
<I><P>Standard 113:</I>&#9;Keep internal class structure hidden from other classes. Do not use global or public data. </P>
<P>&nbsp;</P>
<I><P>Standard 114:</I>&#9;Do not traverse multiple links or member functions in a single statement. Invoke each member function via a temporary pointer or reference. </P>
<P>&nbsp;</P>
<I><P>Standard 115:</I>&#9;Use <FONT FACE="Courier New">const</FONT> wherever a function, parameter or return value will not change. </P>
<P>&nbsp;</P>
<I><P>Guideline 116:</I>&#9;All accessor functions should be <FONT FACE="Courier New">const</FONT>. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Error Handling </P>
</B></FONT><P>Standard 117:</I>&#9;Use exceptions rather than returning a failure status.  However do not use exceptions for conditions that are expected to occur frequently.</P>
<P>&nbsp;</P>
<I><P>Standard 118:</I>&#9;Use assertions (<FONT FACE="Courier New">ASSERT</FONT>, <FONT FACE="Courier New">VERIFY</FONT>, <FONT FACE="Courier New">NEVER_GET_HERE</FONT>) liberally. </P>
<B><FONT FACE="Arial" SIZE=4><P>&nbsp;</P>
<P>File Layout </P>
</B></FONT><I><P>Guideline 66:</I>&#9;Use functional cohesion to group similar items. </P>
<P>&nbsp;</P>
<I><P>Guideline 67:</I>&#9;Source files may be split up along boundaries between class administrator, accessor, mutator and provider functions. </P>
<P>&nbsp;</P>
<I><P>Standard 123:</I>&#9;A class shall have a single header file. </P>
<P>&nbsp;</P>
<I><P>Guideline 68:</I>&#9;Layout data files to reflect the systems they serve. </P>
<P>&nbsp;</P>
<I><P>Standard 124:</I>&#9;Do not reserve memory in header files. </P>
<P>&nbsp;</P>
<I><P>Standard 125:</I>&#9;Minimize header file interdependence. </P>
<P>&nbsp;</P>
<I><P>Guideline 69:</I>&#9;Keep function length in code files to within one or two pages (100 lines). </P>
<P>&nbsp;</P>
<I><P>Guideline 70:</I>&#9;Keep modules small. Each module should be functionally cohesive and should be as small as possible. Modules should not exceed 10-15 pages in length. </P>
<P>&nbsp;</P>
<I><P>Guideline 71:</I>&#9;Classes with a large number of functions should break the implementation into several <FONT FACE="Courier New">.CPP</FONT> files. These files should be functionally cohesive. </P>
<B><I><FONT FACE="Arial"><P>&nbsp;</P>
<P>Header File Layout </P>
</B></FONT><P>Standard 126:</I>&#9;All headers must be wrapped to prevent multiple inclusion. </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>#if !defined(__MYHEADER_H__) </P>
<P>#define __MYHEADER_H__ </P>
<P>...  </P>
<P>#endif // __MYHEADER_H__</P>
</FONT><P>-OR- </P>
<FONT FACE="Courier New"><P>&nbsp;</P>
<P>#pragma once</P>
</FONT><P>&nbsp;</P>
<I><P>Standard 127:</I>&#9;The wrapper must be the name of the file, prefixed with a double underscore <FONT FACE="Courier New">__</FONT> and followed by _<I><FONT FACE="Courier New">H</I>__</FONT>. (i.e. <FONT FACE="Courier New">__COMMON_H__</FONT>). </P>
<P>&nbsp;</P>
<I><P>Standard 128:</I>&#9;public, protected and private line appear in column 0 within a class definition. </P>
<P>&nbsp;</P>
<I><P>Standard 129:</I>&#9;Types, returns, member names, functions must be lined up consistently in header. </P>
<P>&nbsp;</P>
<I><P>Standard 130:</I>&#9;Trailing comments must be aligned within the module. </P>
<P>&nbsp;</P>
<B><FONT SIZE=5><P>Bibliography </P>
</B></FONT><P>Grady Booch. </P><DIR>

<I><P>Object Oriented Analysis and Design With Applications</I>. </P>
<P>Benjamin/Cummings, Redwood City, CA, 2nd edition, 1994. </P></DIR>

<P>The&nbsp;Corelinux Consortium. </P><DIR>

<I><P>The Corelinux C++ Coding Standards</I>. </P>
<P>The Corelinux Consortium, 1.3 edition, May 2000a. </P>
<P>http://corelinux.sourceforge.net/cppstnd.php. </P></DIR>

<P>The&nbsp;Corelinux Consortium. </P><DIR>

<I><P>The Corelinux Object Oriented Design Standards</I>. </P>
<P>The Corelinux Consortium, 1.3 edition, May 2000b. </P></DIR>

<P>Phillip&nbsp;B. Crosby. </P><DIR>

<I><P>Quality Is Free</I>. </P>
<P>McGraw-Hill, New York, NY., 10020, 1976. </P></DIR>

<P>FSF. </P><DIR>

<I><P>GNU Autoconf Manual</I>. </P>
<P>FSF, 2.13 edition, 1999. </P></DIR>

<P>FSF. </P><DIR>

<I><P>GNU Automake Manual</I>. </P>
<P>FSF, 1.4 edition, 2000a. </P></DIR>

<P>FSF. </P><DIR>

<I><P>GNU Libtool Manual</I>. </P>
<P>FSF, 1.3.4 edition, 2000b. </P></DIR>

<P>D.E. Knuth. </P><DIR>

<P>Structured programming with goto's. </P>
<I><P>ACM Computing Surveys</I>, Vol 6(No. 4), December 1974. </P></DIR>

<P>Bertrand Meyer. </P><DIR>

<I><P>Object Oriented Software Construction</I>. </P>
<P>Prentice Hall, Englewood Cliffs, NJ, 1988. </P></DIR>

<P>Inc. Taligent. </P><DIR>

<I><P>The Taligent Guide to Well-Mannered Object-Oriented Programs</I>. </P>
<P>Taligent Inc., Cupertino, CA., 1994. </P>
<P>&nbsp;</P></DIR>

<I><P>Frank V. Castellucci 2001-01-01 </P>
<P>Modifications John Adcock 2001-07-13</P>
</I><P>&nbsp;</P>
<P>&nbsp;</P></BODY>
</HTML>
